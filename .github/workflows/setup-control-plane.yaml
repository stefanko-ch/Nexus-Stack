name: Setup Nexus Control Plane

on:
  workflow_dispatch:
  workflow_call:
    outputs:
      r2_access_key_id:
        description: 'R2 Access Key ID (for spin-up workflow)'
        value: ${{ jobs.deploy.outputs.r2_access_key_id }}
      r2_secret_access_key:
        description: 'R2 Secret Access Key (for spin-up workflow)'
        value: ${{ jobs.deploy.outputs.r2_secret_access_key }}
      ssh_public_key:
        description: 'SSH Public Key (for spin-up workflow)'
        value: ${{ jobs.deploy.outputs.ssh_public_key }}

permissions:
  contents: read
  actions: write

# NOTE: No concurrency here - handled by calling workflow (initial-setup.yaml)
# When called directly via workflow_dispatch, runs without concurrency lock

jobs:
  deploy:
    name: Setup Nexus Control Plane
    runs-on: ubuntu-latest
    outputs:
      r2_access_key_id: ${{ steps.r2_credentials.outputs.r2_access_key_id }}
      r2_secret_access_key: ${{ steps.r2_credentials.outputs.r2_secret_access_key }}
      ssh_public_key: ${{ steps.ssh_key.outputs.ssh_public_key }}
    env:
      TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
      TF_VAR_domain: ${{ secrets.DOMAIN }}
      TF_VAR_access_emails: ${{ secrets.ACCESS_EMAILS }}
      TF_VAR_infisical_token: ${{ secrets.INFISICAL_TOKEN }}
      TF_VAR_dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
      TF_VAR_dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}
      TF_VAR_github_owner: ${{ github.repository_owner }}
      TF_VAR_github_repo: ${{ github.event.repository.name }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: 1.10.0

      - name: Install cloudflared
        run: |
          curl -fsSL https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o cloudflared
          chmod +x cloudflared
          sudo mv cloudflared /usr/local/bin/

      - name: Generate SSH key for server access
        id: ssh_key
        env:
          GH_TOKEN: ${{ secrets.GH_SECRETS_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          # Ensure .ssh directory exists
          mkdir -p ~/.ssh
          
          # Check if SSH key already exists in secrets
          if [ -n "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "âœ… SSH key already exists in secrets - reusing"
            echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
            echo "${{ secrets.SSH_PUBLIC_KEY }}" > ~/.ssh/id_ed25519.pub
            chmod 600 ~/.ssh/id_ed25519
            chmod 644 ~/.ssh/id_ed25519.pub
            echo "ssh_key_created=false" >> $GITHUB_OUTPUT
          else
            echo "ðŸ”‘ Generating new SSH key..."
            mkdir -p ~/.ssh
            ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -N "" -C "nexus-stack"
            chmod 600 ~/.ssh/id_ed25519
            chmod 644 ~/.ssh/id_ed25519.pub
            
            # Save SSH keys as GitHub Secrets
            SSH_PRIVATE_KEY=$(cat ~/.ssh/id_ed25519)
            SSH_PUBLIC_KEY=$(cat ~/.ssh/id_ed25519.pub)
            
            if [ -n "$GH_TOKEN" ]; then
              echo "ðŸ” Saving SSH keys to GitHub Secrets..."
              if gh secret set SSH_PRIVATE_KEY -b "$SSH_PRIVATE_KEY" 2>/dev/null && \
                 gh secret set SSH_PUBLIC_KEY -b "$SSH_PUBLIC_KEY" 2>/dev/null; then
                echo "âœ… SSH keys saved to GitHub Secrets"
                echo "ssh_key_created=true" >> $GITHUB_OUTPUT
              else
                echo "âš ï¸  Failed to save SSH keys - GH_SECRETS_TOKEN may need 'repo' scope"
                echo "ssh_key_created=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "âš ï¸  GH_SECRETS_TOKEN not set - SSH keys not saved"
              echo "ssh_key_created=false" >> $GITHUB_OUTPUT
            fi
          fi
          
          # Export public key for output
          echo "ssh_public_key=$(cat ~/.ssh/id_ed25519.pub)" >> $GITHUB_OUTPUT

      - name: Compute resource prefix
        id: prefix
        run: |
          # Derive resource prefix from domain (e.g., stefanko.ch -> nexus-stefanko-ch)
          DOMAIN="${{ secrets.DOMAIN }}"
          RESOURCE_PREFIX="nexus-${DOMAIN//./-}"
          PROJECT_NAME="${RESOURCE_PREFIX}-control"
          echo "resource_prefix=$RESOURCE_PREFIX" >> $GITHUB_OUTPUT
          echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          echo "Resource prefix: $RESOURCE_PREFIX"
          echo "Project name: $PROJECT_NAME"

      - name: Generate config.tfvars
        run: |
          # Read admin_email and user_email from services.tfvars (committed to repo)
          ADMIN_EMAIL=$(awk -F'"' '/^admin_email/ {print $2}' tofu/services.tfvars)
          USER_EMAIL=$(awk -F'"' '/^user_email/ {print $2}' tofu/services.tfvars)
          
          echo "Admin email: $ADMIN_EMAIL"
          echo "User email: $USER_EMAIL"
          
          # Control Plane config (server_name removed - resource_prefix is derived from domain)
          cat > tofu/control-plane/config.tfvars << EOF
          server_type     = "cax31"
          server_location = "fsn1"
          domain          = "${{ secrets.DOMAIN }}"
          admin_email     = "$ADMIN_EMAIL"
          user_email      = "$USER_EMAIL"
          github_owner    = "${{ github.repository_owner }}"
          github_repo     = "${{ github.event.repository.name }}"
          EOF

      - name: Check if R2 credentials exist
        id: check_r2
        run: |
          if [ -n "${{ secrets.R2_ACCESS_KEY_ID }}" ] && [ -n "${{ secrets.R2_SECRET_ACCESS_KEY }}" ]; then
            echo "r2_exists=true" >> $GITHUB_OUTPUT
            echo "âœ… R2 credentials found in secrets"
          else
            echo "r2_exists=false" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ No R2 credentials - will create new ones"
          fi

      - name: Initialize R2 (first-time setup)
        if: steps.check_r2.outputs.r2_exists == 'false'
        id: init_r2
        env:
          GH_TOKEN: ${{ secrets.GH_SECRETS_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸª£ Creating R2 bucket and credentials..."
          r2_saved=false
          
          # Run the init script
          chmod +x scripts/init-r2-state.sh
          ./scripts/init-r2-state.sh
          
          # Read the generated credentials
          if [ -f tofu/.r2-credentials ]; then
            source tofu/.r2-credentials
            
            # Check if we have a token to auto-save secrets
            if [ -n "$GH_TOKEN" ]; then
              echo "ðŸ” Auto-saving R2 credentials as GitHub Secrets..."
              
              SECRET_ERROR=""
              if ! gh secret set R2_ACCESS_KEY_ID -b "$R2_ACCESS_KEY_ID" 2>&1 | tee /tmp/gh-secret-access.log; then
                SECRET_ERROR=$(cat /tmp/gh-secret-access.log 2>/dev/null || echo "Unknown error")
              fi
              
              if [ -z "$SECRET_ERROR" ]; then
                if ! gh secret set R2_SECRET_ACCESS_KEY -b "$R2_SECRET_ACCESS_KEY" 2>&1 | tee /tmp/gh-secret-secret.log; then
                  SECRET_ERROR=$(cat /tmp/gh-secret-secret.log 2>/dev/null || echo "Unknown error")
                fi
              fi
              
              if [ -z "$SECRET_ERROR" ]; then
                echo "âœ… R2 credentials saved to GitHub Secrets automatically!"
                echo ""
                echo "Future deployments will use these credentials."
                r2_saved=true
              else
                echo "âš ï¸  Failed to auto-save secrets: $SECRET_ERROR"
                echo ""
                echo "Please save these credentials manually in GitHub Secrets:"
                echo "  R2_ACCESS_KEY_ID=$R2_ACCESS_KEY_ID"
                echo "  R2_SECRET_ACCESS_KEY=*** (check workflow logs or tofu/.r2-credentials file)"
                echo ""
                echo "Or configure GH_SECRETS_TOKEN with 'repo' scope and 'write:secrets' permission"
              fi
            else
              echo ""
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘  âš ï¸  GH_SECRETS_TOKEN not configured - manual setup required                â•‘"
              echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
              echo "â•‘                                                                              â•‘"
              echo "â•‘  Please save these credentials manually in GitHub Secrets:                  â•‘"
              echo "â•‘  R2_ACCESS_KEY_ID=$R2_ACCESS_KEY_ID"
              echo "â•‘  R2_SECRET_ACCESS_KEY=$R2_SECRET_ACCESS_KEY"
              echo "â•‘                                                                              â•‘"
              echo "â•‘  To enable auto-saving, create a Personal Access Token:                     â•‘"
              echo "â•‘  GitHub â†’ Settings â†’ Developer settings â†’ Personal access tokens            â•‘"
              echo "â•‘  Required scope: 'repo' (or fine-grained with 'Secrets' permission)         â•‘"
              echo "â•‘  Save as: GH_SECRETS_TOKEN                                                  â•‘"
              echo "â•‘                                                                              â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            fi
            
            echo "r2_saved=$r2_saved" >> $GITHUB_OUTPUT
            
            # Export for this run
            echo "r2_access_key=$R2_ACCESS_KEY_ID" >> $GITHUB_OUTPUT
            echo "r2_secret_key=$R2_SECRET_ACCESS_KEY" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to create R2 credentials"
            exit 1
          fi

      - name: Create R2 credentials from secrets
        if: steps.check_r2.outputs.r2_exists == 'true'
        run: |
          mkdir -p tofu
          # Trim whitespace and newlines from secrets to avoid auth issues
          R2_ACCESS_KEY_ID=$(echo -n "${{ secrets.R2_ACCESS_KEY_ID }}" | tr -d '[:space:]')
          R2_SECRET_ACCESS_KEY=$(echo -n "${{ secrets.R2_SECRET_ACCESS_KEY }}" | tr -d '[:space:]')
          
          # Generate dynamic bucket name from domain
          BUCKET_NAME=$(echo "${{ secrets.DOMAIN }}" | tr '.' '-')-terraform-state
          echo "ðŸ“¦ Using bucket: $BUCKET_NAME"
          
          cat > tofu/.r2-credentials << EOF
          R2_ACCESS_KEY_ID="${R2_ACCESS_KEY_ID}"
          R2_SECRET_ACCESS_KEY="${R2_SECRET_ACCESS_KEY}"
          EOF
          
          cat > tofu/backend.hcl << EOF
          endpoints = {
            s3 = "https://${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.r2.cloudflarestorage.com"
          }
          bucket = "${BUCKET_NAME}"
          EOF
          
          # Debug: Verify credentials are set (without exposing values)
          echo "âœ… R2 credentials file created"
          echo "   R2_ACCESS_KEY_ID length: ${#R2_ACCESS_KEY_ID}"
          echo "   R2_SECRET_ACCESS_KEY length: ${#R2_SECRET_ACCESS_KEY}"

      - name: Export R2 credentials for spin-up workflow
        id: r2_credentials
        run: |
          source tofu/.r2-credentials
          # Note: Don't mask credentials here - masking prevents them from being
          # passed as workflow outputs (GitHub blocks outputs containing masked values)
          # The credentials will be masked by the receiving workflow when used
          # Export as outputs for the calling workflow
          echo "r2_access_key_id=$R2_ACCESS_KEY_ID" >> $GITHUB_OUTPUT
          echo "r2_secret_access_key=$R2_SECRET_ACCESS_KEY" >> $GITHUB_OUTPUT
          echo "âœ… R2 credentials exported for spin-up workflow"

      - name: Initialize OpenTofu for Control Plane
        run: |
          cd tofu/control-plane
          source ../.r2-credentials
          export AWS_ACCESS_KEY_ID="$R2_ACCESS_KEY_ID"
          export AWS_SECRET_ACCESS_KEY="$R2_SECRET_ACCESS_KEY"
          
          # Create backend config for control-plane with dynamic bucket name
          BUCKET_NAME=$(echo "${{ secrets.DOMAIN }}" | tr '.' '-')-terraform-state
          cat > backend.hcl << EOF
          endpoints = {
            s3 = "https://${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.r2.cloudflarestorage.com"
          }
          bucket = "${BUCKET_NAME}"
          EOF
          
          tofu init -backend-config=backend.hcl

      - name: Deploy Control Plane infrastructure
        run: |
          cd tofu/control-plane
          source ../.r2-credentials
          export AWS_ACCESS_KEY_ID="$R2_ACCESS_KEY_ID"
          export AWS_SECRET_ACCESS_KEY="$R2_SECRET_ACCESS_KEY"
          
          echo "ðŸ—ï¸  Deploying Control Plane infrastructure (Cloudflare Pages + Worker)..."
          tofu apply -var-file=config.tfvars -auto-approve
          
          echo "âœ… Control Plane infrastructure deployed"

      - name: Set Scheduled Teardown Worker secrets
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          GITHUB_TOKEN: ${{ secrets.GH_SECRETS_TOKEN }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
          DOMAIN: ${{ secrets.DOMAIN }}
        run: |
          echo "âš™ï¸  Setting Scheduled Teardown Worker secrets..."
          WORKER_NAME="nexus-scheduled-teardown"
          GITHUB_OWNER="${{ github.repository_owner }}"
          GITHUB_REPO="${{ github.event.repository.name }}"
          
          # Set secrets for the Worker (different from Pages!)
          echo "  Setting GITHUB_TOKEN..."
          echo "$GITHUB_TOKEN" | npx wrangler@latest secret put GITHUB_TOKEN --name="$WORKER_NAME" || echo "âš ï¸  Failed"
          
          echo "  Setting GITHUB_OWNER..."
          echo "$GITHUB_OWNER" | npx wrangler@latest secret put GITHUB_OWNER --name="$WORKER_NAME" || echo "âš ï¸  Failed"
          
          echo "  Setting GITHUB_REPO..."
          echo "$GITHUB_REPO" | npx wrangler@latest secret put GITHUB_REPO --name="$WORKER_NAME" || echo "âš ï¸  Failed"
          
          echo "  Setting DOMAIN..."
          echo "$DOMAIN" | npx wrangler@latest secret put DOMAIN --name="$WORKER_NAME" || echo "âš ï¸  Failed"
          
          if [ -n "$RESEND_API_KEY" ]; then
            echo "  Setting RESEND_API_KEY..."
            echo "$RESEND_API_KEY" | npx wrangler@latest secret put RESEND_API_KEY --name="$WORKER_NAME" || echo "âš ï¸  Failed"
          fi
          
          if [ -n "$ADMIN_EMAIL" ]; then
            echo "  Setting ADMIN_EMAIL..."
            echo "$ADMIN_EMAIL" | npx wrangler@latest secret put ADMIN_EMAIL --name="$WORKER_NAME" || echo "âš ï¸  Failed"
          fi
          
          echo "âœ… Worker secrets configured"

      - name: Set Control Plane environment variables and secrets
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          GITHUB_TOKEN: ${{ secrets.GH_SECRETS_TOKEN }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
          DOMAIN: ${{ secrets.DOMAIN }}
        run: |
          echo "âš™ï¸  Setting Control Plane environment variables and secrets..."
          PROJECT_NAME="${{ steps.prefix.outputs.project_name }}"
          GITHUB_OWNER="${{ github.repository_owner }}"
          GITHUB_REPO="${{ github.event.repository.name }}"
          
          echo "  GITHUB_OWNER: $GITHUB_OWNER"
          echo "  GITHUB_REPO: $GITHUB_REPO"
          echo "  DOMAIN: $DOMAIN"
          
          # Set all variables as Secrets via wrangler
          # Note: Terraform sets environment_variables in Pages project config,
          # but wrangler pages deploy doesn't use those - we need to set them as secrets
          # Secrets work for both production and preview environments automatically
          
          if [ -n "$GITHUB_TOKEN" ]; then
            echo "  Setting GITHUB_TOKEN secret..."
            if ! echo "$GITHUB_TOKEN" | npx wrangler@latest pages secret put GITHUB_TOKEN \
              --project-name="$PROJECT_NAME" 2>&1; then
              echo "âš ï¸  Failed to set GITHUB_TOKEN secret (check token validity and project name)"
            fi
          else
            echo "âš ï¸  GITHUB_TOKEN not provided - Control Plane will not work!"
          fi
          
          echo "  Setting GITHUB_OWNER secret..."
          echo "$GITHUB_OWNER" | npx wrangler@latest pages secret put GITHUB_OWNER \
            --project-name="$PROJECT_NAME" || echo "âš ï¸  Failed to set GITHUB_OWNER (may already be set)"
          
          echo "  Setting GITHUB_REPO secret..."
          echo "$GITHUB_REPO" | npx wrangler@latest pages secret put GITHUB_REPO \
            --project-name="$PROJECT_NAME" || echo "âš ï¸  Failed to set GITHUB_REPO (may already be set)"
          
          # Set DOMAIN (required for service URLs and email sender)
          if [ -n "$DOMAIN" ]; then
            echo "  Setting DOMAIN secret..."
            echo "$DOMAIN" | npx wrangler@latest pages secret put DOMAIN \
              --project-name="$PROJECT_NAME" || echo "âš ï¸  Failed to set DOMAIN"
          else
            echo "âš ï¸  DOMAIN not provided - Service URLs will show 'unknown'!"
          fi
          
          # Set RESEND_API_KEY for email sending (optional)
          if [ -n "$RESEND_API_KEY" ]; then
            echo "  Setting RESEND_API_KEY secret..."
            echo "$RESEND_API_KEY" | npx wrangler@latest pages secret put RESEND_API_KEY \
              --project-name="$PROJECT_NAME" || echo "âš ï¸  Failed to set RESEND_API_KEY"
          else
            echo "  â­ï¸  RESEND_API_KEY not provided - email sending will be disabled"
          fi
          
          # Set ADMIN_EMAIL for email sending (optional)
          if [ -n "$ADMIN_EMAIL" ]; then
            echo "  Setting ADMIN_EMAIL secret..."
            echo "$ADMIN_EMAIL" | npx wrangler@latest pages secret put ADMIN_EMAIL \
              --project-name="$PROJECT_NAME" || echo "âš ï¸  Failed to set ADMIN_EMAIL"
          else
            echo "  â­ï¸  ADMIN_EMAIL not provided - email sending will be disabled"
          fi
          
          echo "âœ… All secrets set (applies to both production and preview environments)"
          
          echo ""
          echo "âœ… Setup complete"
          echo ""
          echo "âš ï¸  IMPORTANT: Environment variables are now set."
          echo "   If Control Plane still shows errors, the deployment may need to be recreated."
          echo "   Triggering a new deployment to ensure variables are available..."

      - name: Deploy Control Plane to Cloudflare Pages
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "ðŸ“¦ Deploying Control Plane to Cloudflare Pages..."
          
          # Get KV namespace ID from Terraform output
          cd tofu/control-plane
          source ../.r2-credentials
          export AWS_ACCESS_KEY_ID="$R2_ACCESS_KEY_ID"
          export AWS_SECRET_ACCESS_KEY="$R2_SECRET_ACCESS_KEY"
          KV_NAMESPACE_ID=$(tofu output -raw kv_namespace_id)
          echo "  KV Namespace ID: $KV_NAMESPACE_ID"
          cd ../..
          
          cd control-plane/pages
          # Verify functions directory exists
          if [ ! -d "functions" ]; then
            echo "âŒ Error: functions/ directory not found - API endpoints are required!"
            exit 1
          fi
          
          # Generate wrangler.toml with KV binding
          # pages_build_output_dir is required for Pages to use the config
          PROJECT_NAME="${{ steps.prefix.outputs.project_name }}"
          cat > wrangler.toml << EOF
          name = "$PROJECT_NAME"
          compatibility_date = "2024-01-01"
          pages_build_output_dir = "."

          [[kv_namespaces]]
          binding = "SCHEDULED_TEARDOWN"
          id = "$KV_NAMESPACE_ID"
          EOF
          
          echo "  Generated wrangler.toml with KV binding"
          cat wrangler.toml
          
          # Deploy to production with KV binding
          # --commit-dirty=true suppresses warning about uncommitted wrangler.toml
          npx wrangler@latest pages deploy . \
            --project-name="$PROJECT_NAME" \
            --branch=main \
            --commit-dirty=true
          
          # Clean up generated wrangler.toml
          rm wrangler.toml
          
          echo "âœ… Control Plane deployed with KV bindings!"

      - name: Show setup info
        run: |
          echo ""
          echo "âœ… Control Plane setup complete!"
          echo ""
          echo "ðŸ“‹ Control Plane: https://control.${{ secrets.DOMAIN }}"
          echo ""
          echo "â„¹ï¸  Next steps:"
          echo "   1. Use the Control Plane to manage your infrastructure"
          echo "   2. Run 'Spin Up' workflow to deploy the Hetzner server and services"
          echo "   3. Or trigger it manually: Actions â†’ Spin Up Nexus-Stack â†’ Run workflow"

